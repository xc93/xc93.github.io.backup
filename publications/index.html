<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>

  Xiaohong Chen


  | publications

</title>
<meta name="description" content="">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css" integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css" integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet" href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->

<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22></text></svg>">

<link rel="stylesheet" href="/assets/css/main.css">
<link rel="canonical" href="/publications/">




  </head>

  <body class="fixed-top-nav ">

    <!-- Header -->

    <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="xchen.page/">
       Xiaohong Chen
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item active">
              <a class="nav-link" href="/publications/">
                publications
                
                <span class="sr-only">(current)</span>
                
              </a>
          </li>
          
          
          
          
        </ul>
      </div>
    </div>
  </nav>

</header>


    <!-- Content -->

    <div class="container mt-5">
      <div class="post">

  <header class="post-header">
    <h1 class="post-title">publications</h1>
    <p class="post-description">listed in reverse chronological order</p>
  </header>

  <article>
    <div class="publications">


  <h2 class="year">2023</h2>
  <ol class="bibliography"><li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="LCT+23" class="col-sm-8">
    
      <div class="title">Generating proof certificates for a language-agnostic deductive program verifier</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                
                  Lin, Zhengyao,
                
              
            
          
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Trinh, Minh-Thai,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Wang, John,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Roşu, Grigore
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Proceedings of OOPSLA (To Appear)</em>
      
      
      
      
        2023
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    
    
    
    
    <a href="https://hdl.handle.net/2142/112785" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">TechRep</a>
    
    
      
      <a href="/assets/pdf/LCT+23-paper.pdf" class="btn btn-sm z-depth-0" role="button">PDF</a>
      
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>A language-agnostic program verifier takes as input both a program with its formal specification and the formal semantics of the programming language in which the program is written, and then uses a language-agnostic verification algorithm to prove the program correct with respect to its specification, using directly the formal language semantics. Such a complex verifier can easily have bugs. This paper proposes a method to certify the correctness of each successful verification run by generating a proof certificate for it. The proof certificate can be checked by a small proof checker. The preliminary experiments apply the method to generate proof certificates for the verification of an imperative language, a functional language, and a virtual machine language, showing that the proposed method is language-agnostic.</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li></ol>

  <h2 class="year">2022</h2>
  <ol class="bibliography">
<li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="CLR22" class="col-sm-8">
    
      <div class="title">Capturing constrained constructor patterns in matching logic</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Lucanu, Dorel,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Roşu, Grigore
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>Journal of Logical and Algebraic Methods in Programming</em>
      
      
      
      
        2022
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    <a href="https://doi.org/10.1016/j.jlamp.2022.100810" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">doi</a>
    
    
    
    
    
    
      
      <a href="/assets/pdf/CLR22-paper.pdf" class="btn btn-sm z-depth-0" role="button">PDF</a>
      
    
    
    
    
    
    
      
      <a href="/assets/pdf/CLR22-slides.pdf" class="btn btn-sm z-depth-0" role="button">Slides</a>
      
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Reachability logic for rewrite theories consists of a specification 
                       of system states that are given by constrained constructor patterns, 
                       a transition relation that is given by a rewrite theory, and reachability 
                       properties expressed as pairs of state specifications. Matching logic 
                       has been recently proposed as a unifying foundation for programming languages, 
                       specification and verification. It is known that reachability properties 
                       can be naturally expressed in matching logic. In this paper, we show 
                       that constrained constructor patterns can be faithfully specified as 
                       a matching logic theory. As a result, we obtain a full encoding of reachability 
                       logic for rewrite theories as matching logic theories, by combining the two encodings. 
                       We also show that the main properties of constrained constructor patterns 
                       can be specified and proved within matching logic, using the existing proof system.</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li>
<li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="ZCS22" class="col-sm-8">
    
      <div class="title">Towards a unifying logical framework for neural networks</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                
                  Zhang, Xiyue,
                
              
            
          
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Sun, Meng
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Proceedings of ICTAC</em>
      
      
      
      
        2022
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    <a href="https://doi.org/10.1007/978-3-031-17715-6_28" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">doi</a>
    
    
    
    
    
    
      
      <a href="/assets/pdf/ZCS22-paper.pdf" class="btn btn-sm z-depth-0" role="button">PDF</a>
      
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Neural networks are increasingly used in safety-critical applications such as medical diagnosis and autonomous driving, which calls for the need for formal specification of their behaviors. In this paper, we use matching logic—a unifying logic to specify and reason about programs and computing systems—to axiomatically define dynamic propagation and temporal operations in neural networks and to formally specify common properties about neural networks. As instances, we use matching logic to formalize a variety of neural networks, including generic feed-forward neural networks with different activation functions and recurrent neural networks. We define their formal semantics and several common properties in matching logic. This way, we obtain a unifying logical framework for specifying neural networks and their properties.</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li>
<li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="BCH+22" class="col-sm-8">
    
      <div class="title">Mechanizing matching logic in Coq</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                
                  Bereczky, Péter,
                
              
            
          
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Horpácsi, Dániel,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Peña, Lucas,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Tušil, Jan
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Proceedings of Working Formal Methods Symposium (FROM)</em>
      
      
      
      
        2022
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    <a href="https://doi.org/10.4204/EPTCS.369.2" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">doi</a>
    
    
    
    
    
    
      
      <a href="/assets/pdf/BCH+22-paper.pdf" class="btn btn-sm z-depth-0" role="button">PDF</a>
      
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Matching logic is a formalism for specifying and reasoning about mathematical structures, using patterns and pattern matching. Growing in popularity, it has been used to define many logical systems such as separation logic with recursive definitions and linear temporal logic. In addition, it serves as the logical foundation of the K semantic framework, which was used to build practical verifiers for a number of real-world languages. Despite being a fundamental formal system accommodating substantial theories, matching logic lacks a general-purpose, machine-checked formalization. Hence, we formalize matching logic using the Coq proof assistant. Specifically, we create a new representation of matching logic that uses a locally nameless encoding, and we formalize the syntax, semantics, and proof system of this representation in the Coq proof assistant. Crucially, we prove the soundness of the formalized proof system and provide a means to carry out interactive matching logic reasoning in Coq. We believe this work provides a previously unexplored avenue for reasoning about matching logic, its models, and the proof system.</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li>
<li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="SCS+22" class="col-sm-8">
    
      <div class="title">Rewriting-based computer-interpretable clinical practice guidelines</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                
                  Saxena, Manasvi,
                
              
            
          
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Song, Shuang,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Meng, Shaoyu,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Sha, Lui,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Roşu, Grigore
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>Technical Report</em>
      
      
      
      
        2022
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    
    
    
    
    <a href="https://hdl.handle.net/2142/116016" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">TechRep</a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Clinical Practice Guidelines (CPGs) are systematically developed statements to assist healthcare professionals with decisions about specific clinical circumstances. Produced by domain experts, they they codify recommended treatments, and are often used as models for building Decision Support Systems (DSS) that assist healthcare professionals adhere to CPGs. CPGs are usually specified informally, or semi-formally (via flowcharts). This, however, may cause the behavior of DSSs to deviate from intended treatment in the corresponding CPGs, and introduce challenges in verifying correctness of the DSSs. In this paper, we propose a novel method of formally specifying CPGs by for- malizing them in K, a rewriting-based executable semantics framework [13]. Our K-based guidelines are executable, allowing them to serve as correct-by-construction models in DSSs, and can be analyzed using tools in the K ecosystem. To support our claims, we present a DSS based on Advanced Cardiac Life Support (ACLS) CPG formalized in K, discuss challenges and present directions for future work.</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li>
</ol>

  <h2 class="year">2021</h2>
  <ol class="bibliography">
<li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="CLTR21" class="col-sm-8">
    
      <div class="title">Towards a trustworthy semantics-based language framework via proof generation</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Lin, Zhengyao,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Trinh, Minh-Thai,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Roşu, Grigore
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Proceedings of CAV</em>
      
      
      
      
        2021
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    <a href="https://doi.org/10.1007/978-3-030-81688-9_23" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">doi</a>
    
    
    
    
    
    
      
      <a href="/assets/pdf/CLTR21-paper.pdf" class="btn btn-sm z-depth-0" role="button">PDF</a>
      
    
    
    
    
    
    
      
      <a href="/assets/pdf/CLTR21-slides.pdf" class="btn btn-sm z-depth-0" role="button">Slides</a>
      
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>We pursue the vision of an ideal language framework, where programming 
language designers only need to define the formal syntax and semantics
of their languages, and all language tools are automatically  generated
by the framework. Due to the complexity of such a language framework,
it is a big challenge to  ensure its trustworthiness and to  establish
the correctness of the autogenerated language tools.  In this paper, we
propose an innovative approach based on  proof generation. The key idea
is to generate proof objects as correctness certificates for each
individual task that the language tools conduct, on a case-by-case basis,
and use a trustworthy proof checker to check the proof objects. This way,
we avoid formally verifying the entire framework, which is practically
impossible, and thus can make the language framework both practical and
trustworthy. As a first step, we formalize program execution as mathematical
proofs and generate their complete proof objects. The experimental result
shows that the performance of our proof object generation and proof
checking is very promising.</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li>
<li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="CR21" class="col-sm-8">
    
      <div class="title">The K vision for the future of programming language design and analysis</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Roşu, Grigore
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>Formal Methods in Outer Space</em>
      
      
      
      
        2021
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    <a href="https://doi.org/10.1016/j.jlamp.2021.100638" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">doi</a>
    
    
    
    
    
    
      
      <a href="/assets/pdf/CR21-paper.pdf" class="btn btn-sm z-depth-0" role="button">PDF</a>
      
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Formal programming language semantics should be a unique opportunity to give birth to a better language, not a cumbersome post-mortem activity. Moreover, language implementations and analysis tools should be automatically generated from the formal semantics in a correct-by-construction manner, at no additional cost. In this paper, we discuss how we are pursuing this vision of programming language design and analysis within the context of the K framework (http://kframework.org), where it is easy and fun to design and deploy new programming languages; where language designers can focus on the desired features and not worry about their implementation; and where the correctness of all auto-generated language implementations and tools is guaranteed on a case-by-case basis, and every individual task, be it parsing, execution, verification, or anything else, is endorsed by its own proof object that can be independently checked by third-party proof checkers, making no compromise to safety or correctness.</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li>
<li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="CLR21" class="col-sm-8">
    
      <div class="title">Matching logic explained</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Lucanu, Dorel,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Roşu, Grigore
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>Journal of Logical and Algebraic Methods in Programming</em>
      
      
      
      
        2021
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    <a href="https://doi.org/10.1016/j.jlamp.2021.100638" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">doi</a>
    
    
    
    
    
    
      
      <a href="/assets/pdf/CLR21-paper.pdf" class="btn btn-sm z-depth-0" role="button">PDF</a>
      
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Matching logic was recently proposed as a unifying logic for specifying and reasoning about static structure and dynamic behavior of programs. In matching logic, patterns and specifications are used to uniformly represent mathematical domains (such as numbers and Boolean values), datatypes, and transition systems, whose properties can be reasoned about using one fixed matching logic proof system. In this paper we give a tutorial of matching logic. We use a suite of examples to explain the basic concepts of matching logic and show how to capture many important mathematical domains, datatypes, and transition systems using patterns and specifications. We put emphasis on the general principles of induction and coinduction in matching logic and show how to do inductive and coinductive reasoning about datatypes and codatatypes. To encourage the future tools development for matching logic, we propose and use throughout the paper a human-readable formal syntax to write specifications in a modular and compact way.</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li>
<li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="LCT+21" class="col-sm-8">
    
      <div class="title">Making formal verification trustworthy via proof generation</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                
                  Lin, Zhengyao,
                
              
            
          
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Trinh, Minh-Thai,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Wang, John,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Roşu, Grigore
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>Technical Report</em>
      
      
      
      
        2021
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    
    
    
    
    <a href="https://hdl.handle.net/2142/112785" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">TechRep</a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Formal deductive verification aims at proving the correctness of programs via logical deduction. However, the fact that it is usually based on complex program logics makes it error-prone to implement. This paper addresses the important research question of how we can make a deductive verifier trustworthy through a practical approach. We propose a novel technique to generate machine-checkable proof objects to certify each verification task performed by the language-agnostic deductive verifier of K—a semantics-based language framework. These proof objects encode formal proofs in matching logic—the logical foundation of K. They have a small 240-line trust base and can be directly verified by third-party proof checkers. Our preliminary experiments show promising performance in generating correctness proofs for deductive verification in different programming languages.</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li>
<li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="LCR21" class="col-sm-8">
    
      <div class="title">An interactive theorem prover for matching logic with proof object generation</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                
                  Lin, Zhengyao,
                
              
            
          
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Roşu, Grigore
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>Technical Report</em>
      
      
      
      
        2021
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    
    
    
    
    <a href="https://hdl.handle.net/2142/111650" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">TechRep</a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Matching logic is a uniform logical foundation for K, which is a language semantics framework with the philosophy that all tooling around a language should be automatically generated from a single, rigorous definition of its formal semantics. In practice, K has been widely used to define the formal semantics of many real-world languages and to generate their execution and verification tools. However, there lacks a generic theorem prover that connects K with its logical foundation—matching logic. In this paper, we present ITP_ML, which is the first interactive theorem prover for matching logic. The main advantage of ITP_ML is its ability to generate machine-checkable proof objects as certificates that witness the correctness of its formal reasoning. ITP_ML is built on top of Metamath, a language to define formal systems, which allows it to have a small trust base of only 250 lines of code. ITP_ML supports both backward and forward proofs, allows users to dynamically add intermediate lemmas, and features automated proof tactics for common utilities such as reasoning about notations and proving propositional tautologies.</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li>
</ol>

  <h2 class="year">2020</h2>
  <ol class="bibliography">
<li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="CR20" class="col-sm-8">
    
      <div class="title">A general approach to define binders using matching logic</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Roşu, Grigore
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Proceedings of ICFP</em>
      
      
      
      
        2020
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    <a href="https://doi.org/10.1145/3408970" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">doi</a>
    
    
    
    
    <a href="https://www.youtube.com/watch?v=TNO_jGr33VM" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">TALK</a>
    
    
    <a href="https://hdl.handle.net/2142/106608" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">TechRep</a>
    
    
      
      <a href="/assets/pdf/CR20-paper.pdf" class="btn btn-sm z-depth-0" role="button">PDF</a>
      
    
    
    
    
    
    
      
      <a href="/assets/pdf/CR20-slides.pdf" class="btn btn-sm z-depth-0" role="button">Slides</a>
      
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>We propose a novel definition of binders using matching logic, where the binding behavior of object-level binders is directly inherited from the built-in exists binder of matching logic. We show that the behavior of binders in various logical systems such as lambda-calculus, System F, pi-calculus, pure type systems, can be axiomatically defined in matching logic as notations and logical theories. We show the correctness of our definitions by proving conservative extension theorems, which state that a sequent/judgment is provable in the original system if and only if it is provable in matching logic, in the corresponding theory. Our matching logic definition of binders also yields models to all binders, which are deductively complete with respect to formal reasoning in the original systems. For lambda-calculus, we further show that the yielded models are representationally complete, a desired property that is not enjoyed by many existing lambda-calculus semantics. This work is part of a larger effort to develop a logical foundation for the programming language semantics framework K (http://kframework.org).</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li>
<li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="CTR+20" class="col-sm-8">
    
      <div class="title">Towards A unified proof framework for automated fixpoint reasoning using matching logic</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Trinh, Minh-Thai,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Rodrigues, Nishant,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Peña, Lucas,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Roşu, Grigore
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Proceedings of OOPSLA</em>
      
      
      
      
        2020
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    <a href="https://doi.org/10.1145/3428229" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">doi</a>
    
    
    
    
    <a href="https://www.youtube.com/watch?v=2JlaJPPilB0" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">TALK</a>
    
    
    
      
      <a href="/assets/pdf/CTR+20-paper.pdf" class="btn btn-sm z-depth-0" role="button">PDF</a>
      
    
    
    
    
    
    
      
      <a href="/assets/pdf/CTR+20-slides.pdf" class="btn btn-sm z-depth-0" role="button">Slides</a>
      
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Automation of fixpoint reasoning has been extensively studied for various mathematical structures, logical formalisms, and computational domains, resulting in specialized fixpoint provers for heaps, for streams, for term algebras, for temporal properties, for program correctness, and for many other formal systems and inductive and coinductive properties. However, in spite of great theoretical and practical interest, there is no unified framework for automated fixpoint reasoning. Although several attempts have been made, there is no evidence that such a unified framework is possible, or practical. In this paper, we propose a candidate based on matching logic, a formalism recently shown to theoretically unify the above mentioned formal systems. Unfortunately, the (Knaster-Tarski) proof rule of matching logic, which enables inductive reasoning, is not syntax-driven. Worse, it can be applied at any step during a proof, making automation seem hopeless. Inspired by recent advances in automation of inductive proofs in separation logic, we propose an alternative proof system for matching logic, which is amenable for automation. We then discuss our implementation of it, which although not superior to specialized state-of-the-art automated provers for specific domains, we believe brings some evidence and hope that a unified framework for automated reasoning is not out of reach.</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li>
<li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="CR20a" class="col-sm-8">
    
      <div class="title">K—A semantic framework for programming languages and formal analysis</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Roşu, Grigore
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Lecture Notes of the International School on Engineering Trustworthy Software Systems</em>
      
      
      
      
        2020
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    <a href="https://doi.org/10.1007/978-3-030-55089-9_4" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">doi</a>
    
    
    
    
    
    
      
      <a href="/assets/pdf/CR20a-paper.pdf" class="btn btn-sm z-depth-0" role="button">PDF</a>
      
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>We give an overview on the applications and foundations of the K language framework, a semantic framework for programming languages and formal analysis tools. K represents a 20-year effort in pursuing the ideal language framework vision, where programming languages must have formal definitions, and tools for a given language, such as parsers, interpreters, compilers, semantic-based debuggers, state-space explorers, model checkers, deductive program verifiers, etc., can be derived from just one reference formal definition of the language, which is executable, and no other semantics for the same language should be needed. The correctness of the language tools is guaranteed on a case-by-case basis by proof objects, which encode rigorous mathematical proofs as certificates for every individual task that the tools do and can be mechanically checked by third-party proof checkers.</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li>
<li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="CLR20" class="col-sm-8">
    
      <div class="title">Initial algebra semantics in matching logic</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Lucanu, Dorel,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Roşu, Grigore
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>Technical Report</em>
      
      
      
      
        2020
      
      </div>
    

    <div class="links">
    
    
    
    
    
    
    
    <a href="http://hdl.handle.net/2142/107781" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">TechRep</a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li>
</ol>

  <h2 class="year">2019</h2>
  <ol class="bibliography"><li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="CR19" class="col-sm-8">
    
      <div class="title">Matching μ-logic</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Roşu, Grigore
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Proceedings of LICS</em>
      
      
      
      
        2019
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    <a href="https://doi.org/10.1109/LICS.2019.8785675" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">doi</a>
    
    
    
    
    
    <a href="https://hdl.handle.net/2142/102281" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">TechRep</a>
    
    
      
      <a href="/assets/pdf/CR19-paper.pdf" class="btn btn-sm z-depth-0" role="button">PDF</a>
      
    
    
    
    
    
    
      
      <a href="/assets/pdf/CR19-slides.pdf" class="btn btn-sm z-depth-0" role="button">Slides</a>
      
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Matching logic is a logic for specifying and reasoning about
               structure by means of patterns and pattern matching.
               This paper makes two contributions.
               First, it proposes a sound and complete proof system for
               matching logic in its full generality.
               Previously, sound and complete deduction for matching logic
               was known only for particular theories providing equality
               and membership.
               Second, it proposes matching μ-logic, an extension of
               matching logic with a least fixpoint μ-binder.
               It is shown that matching μ-logic captures as special instances many
               important logics in mathematics and computer science, including
               first-order logic with least fixpoints, modal mu-logic
               as well as dynamic logic and various temporal logics such as
               infinite/finite-trace linear temporal logic and computation tree logic,
               and notably reachability logic, the underlying logic of the K framework
               for programming language semantics and formal analysis.
               Matching μ-logic therefore serves as a unifying foundation for
               specifying and reasoning about fixpoints and induction, 
               programming languages and program specification and verification.</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li></ol>

  <h2 class="year">2018</h2>
  <ol class="bibliography">
<li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="CR18" class="col-sm-8">
    
      <div class="title">A language-independent program verification framework</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Roşu, Grigore
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Proceedings of ISoLA</em>
      
      
      
      
        2018
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    <a href="https://doi.org/10.1007/978-3-030-03421-4_7" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">doi</a>
    
    
    
    
    
    
      
      <a href="/assets/pdf/CR18-paper.pdf" class="btn btn-sm z-depth-0" role="button">PDF</a>
      
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>This invited paper describes an approach to language-independent deductive verification using the K semantics framework, in which an operational semantics of a language is defined and a program verifier together with other language tools are generated automatically, correct-by-construction.</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li>
<li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="CPR18" class="col-sm-8">
    
      <div class="title">A language-independent approach to smart contract verification</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Park, Daejun,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Roşu, Grigore
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Proceedings of ISoLA</em>
      
      
      
      
        2018
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    <a href="https://doi.org/10.1007/978-3-030-03427-6_30" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">doi</a>
    
    
    
    
    
    
      
      <a href="/assets/pdf/CPR18-paper.pdf" class="btn btn-sm z-depth-0" role="button">PDF</a>
      
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>This invited paper reports the current progress on smart contract verification with the K framework in a language-independent style.</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li>
</ol>

  <h2 class="year">2017</h2>
  <ol class="bibliography"><li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="WCSQ17" class="col-sm-8">
    
      <div class="title">Improving probability estimation through active probabilistic model learning</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                
                  Wang, Jingyi,
                
              
            
          
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Sun, Jun,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Qin, Shengchao
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Proceedings of ICFEM</em>
      
      
      
      
        2017
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    <a href="https://doi.org/10.1007/978-3-319-68690-5_23" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">doi</a>
    
    
    
    
    
    
      
      <a href="/assets/pdf/WCSQ17-paper.pdf" class="btn btn-sm z-depth-0" role="button">PDF</a>
      
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>It is often necessary to estimate the probability of certain events occurring in a system. For instance, knowing the probability of events triggering a shutdown sequence allows us to estimate the availability of the system. One approach is to run the system multiple times and then construct a probabilistic model to estimate the probability. When the probability of the event to be estimated is low, many system runs are necessary in order to generate an accurate estimation. For complex cyber-physical systems, each system run is costly and time-consuming, and thus it is important to reduce the number of system runs while providing accurate estimation. In this work, we assume that the user can actively tune the initial configuration of the system before the system runs and answer the following research question: how should the user set the initial configuration so that a better estimation can be learned with fewer system runs. The proposed approach has been implemented and evaluated with a set of benchmark models, random generated models, and a real-world water treatment system.</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li></ol>

  <h2 class="year">2016</h2>
  <ol class="bibliography">
<li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="PCL+16" class="col-sm-8">
    
      <div class="title">Component-based modelling for scalable smart city systems interoperability: A case study on integrating energy demand response systems</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                
                  Palomar, Esther,
                
              
            
          
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Liu, Zhiming,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Maharjan, Sabita,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Bowen, Jonathan
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>Sensors</em>
      
      
      
      
        2016
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    <a href="https://doi.org/10.3390/s16111810" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">doi</a>
    
    
    
    
    
    
      
      <a href="/assets/pdf/PCL+16-paper.pdf" class="btn btn-sm z-depth-0" role="button">PDF</a>
      
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Smart city systems embrace major challenges associated with climate change, energy efficiency, mobility and future services by embedding the virtual space into a complex cyber-physical system. Those systems are constantly evolving and scaling up, involving a wide range of integration among users, devices, utilities, public services and also policies. Modelling such complex dynamic systems’ architectures has always been essential for the development and application of techniques/tools to support design and deployment of integration of new components, as well as for the analysis, verification, simulation and testing to ensure trustworthiness. This article reports on the definition and implementation of a scalable component-based architecture that supports a cooperative energy demand response (DR) system coordinating energy usage between neighbouring households. The proposed architecture, called refinement of Cyber-Physical Component Systems (rCPCS), which extends the refinement calculus for component and object system (rCOS) modelling method, is implemented using Eclipse Extensible Coordination Tools (ECT), i.e., Reo coordination language. With rCPCS implementation in Reo, we specify the communication, synchronisation and co-operation amongst the heterogeneous components of the system assuring, by design scalability and the interoperability, correctness of component cooperation.</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li>
<li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="KLC+16" class="col-sm-8">
    
      <div class="title">Towards concolic testing for hybrid systems</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                
                  Kong, Pingfan,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Li, Yi,
                
              
            
          
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Sun, Jun,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Sun, Meng,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Wang, Jingyi
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Proceedings of FM</em>
      
      
      
      
        2016
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    <a href="https://doi.org/10.1007/978-3-319-48989-6_28" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">doi</a>
    
    
    
    
    
    
      
      <a href="/assets/pdf/KLC+16-paper.pdf" class="btn btn-sm z-depth-0" role="button">PDF</a>
      
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Hybrid systems exhibit both continuous and discrete behavior. Analyzing hybrid systems is known to be hard. Inspired by the idea of concolic testing (of programs), we investigate whether we can combine random sampling and symbolic execution in order to effectively verify hybrid systems. We identify a sufficient condition under which such a combination is more effective than random sampling. Furthermore, we analyze different strategies of combining random sampling and symbolic execution and propose an algorithm which allows us to dynamically switch between them so as to reduce the overall cost. Our method has been implemented as a web-based checker named HyChecker. HyChecker has been evaluated with benchmark hybrid systems and a water treatment system in order to test its effectiveness.</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li>
<li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="LC16" class="col-sm-8">
    
      <div class="title">Model-driven design of object and component systems</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                
                  Liu, Zhiming,
                
              
            
          
        
          
          
          
          
          
          
            
              
                and <em>Chen, Xiaohong</em>
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Lecture Notes of the International School on Engineering Trustworthy Software Systems</em>
      
      
      
      
        2016
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    <a href="https://doi.org/10.1007/978-3-319-29628-9_4" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">doi</a>
    
    
    
    
    
    
      
      <a href="/assets/pdf/LC16-paper.pdf" class="btn btn-sm z-depth-0" role="button">PDF</a>
      
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>The notion of software engineering implies that software design and production should be based on the types of theoretical foundations and practical disciplines that are established in the traditional branches of engineering. The goal is to make development of complex software systems more predictable and the systems developed more trustworthy - safe, secure and dependable. A number of theories have been well developed in the past half a century, including Abstract Data Types, Hoare Logic, Process Calculi, and I/O automata, and those alike. Based on them, techniques and tools have been developed for software specification, refinement and verification.
However, the theoretically sound techniques and tools have not been seamlessly integrated in practical software development, and their impact upon commonly-used software systems is still far from convincing to software engineering practitioners. This is clearly reflected by the challenges of their applications in engineering large-scale systems, including Cyber-Physical Systems (CPS), Networks of Things and Cloud-Based Systems, that have multi-dimensional complexities. Indeed, students are not often shown how the theories, and their underpinned techniques and tools, can better inform the software engineering they are traditionally taught. The purpose of this course to demonstrate such an effort.
We present a model-driven design framework for component-based and object-oriented software systems. We identify a set of UML notations and textual descriptions for representing different abstractions of software artefacts produced in different development stages. These abstractions, their relations and manipulations all have formalisations in the rCOS formal method of component and object systems. The aim is to allow the advantage of using precise models for development better appreciated. We organise the lecture notes into three chapters, each having a title page but all the references to literature are given at the end of Part III.</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li>
</ol>

  <h2 class="year">2015</h2>
  <ol class="bibliography"><li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="LCWS15" class="col-sm-8">
    
      <div class="title">A framework for off-line conformance testing of timed connectors</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                
                  Li, Shaodong,
                
              
            
          
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Wang, Yiwu,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Sun, Meng
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Proceedings of TASE</em>
      
      
      
      
        2015
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    <a href="https://doi.org/10.1109/TASE.2015.9" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">doi</a>
    
    
    
    
    
    
      
      <a href="/assets/pdf/LCWS15-paper.pdf" class="btn btn-sm z-depth-0" role="button">PDF</a>
      
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Coordination is playing a key role in complex cyber-physicalsystems (CPSs). The complexity and importance of coordination models and languages for CPSs necessarily lead to a higher relevance of testing during development of CPSs. Model-based testing is a promising technology to test the conformance or non-conformance relation between the implementation-under-test (IUT) and its specification. In this paper, we present an approach to test the conformance relation tiococ(Timed Input-Output Conformance) between the implementation of a timed Reo connector and its specification given by a timed constraint automaton (TCA). An algorithm to generate test cases from a TCA is proposed and the testing approach is implemented in UPPAAL.</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li></ol>

  <h2 class="year">2014</h2>
  <ol class="bibliography"><li>
<div class="row">
  <div class="col-sm-2 abbr">
  
  </div>

  <div id="CSS14" class="col-sm-8">
    
      <div class="title">A hybrid model of connectors in cyber-physical systems</div>
      <div class="author">
        
          
          
          
          
          
          
            
              
                <em>Chen, Xiaohong</em>,
              
            
          
        
          
          
          
          
          
          
            
              
                
                  Sun, Jun,
                
              
            
          
        
          
          
          
          
          
          
            
              
                
                  and Sun, Meng
                
              
            
          
        
      </div>

      <div class="periodical">
      
        <em>In Proceedings of ICFEM</em>
      
      
      
      
        2014
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
    
    
    
    <a href="https://doi.org/10.1007/978-3-319-11737-9_5" class="btn btn-sm z-depth-0" role="button" target="_blank" rel="noopener noreferrer">doi</a>
    
    
    
    
    
    
      
      <a href="/assets/pdf/CSS14-paper.pdf" class="btn btn-sm z-depth-0" role="button">PDF</a>
      
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Coordination is playing a key role in complex cyber-physicalsystems (CPSs). The complexity and importance of coordination models and languages for CPSs necessarily lead to a higher relevance of testing during development of CPSs. Model-based testing is a promising technology to test the conformance or non-conformance relation between the implementation-under-test (IUT) and its specification. In this paper, we present an approach to test the conformance relation tiococ(Timed Input-Output Conformance) between the implementation of a timed Reo connector and its specification given by a timed constraint automaton (TCA). An algorithm to generate test cases from a TCA is proposed and the testing approach is implemented in UPPAAL.</p>
    </div>
    

    <!-- Hidden bibtex block -->
    
  </div>
</div>
</li></ol>


</div>

  </article>

</div>

    </div>

    <!-- Footer -->

    
<footer class="fixed-bottom">
  <div class="container mt-0">
    © Copyright 2023 Xiaohong  Chen.
    
    
    
  </div>
</footer>



  </body>

  <!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>

  <!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>

  
<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>


  


<!-- Medium Zoom JS -->
<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
<script src="/assets/js/zoom.js"></script>


<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>

  
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  





</html>
