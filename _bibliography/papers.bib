---
---

@InProceedings{LCT+23,
  author            = {Lin, Zhengyao and Chen, Xiaohong and Trinh, Minh-Thai and Wang, John and Ro{\c{s}}u, Grigore},
  title             = {Generating proof certificates for a language-agnostic deductive program verifier},
  booktitle         = {Proceedings of OOPSLA (To Appear)},
  year              = {2023},
  abstract          = {A language-agnostic program verifier takes as input both a program with its formal specification and the formal semantics of the programming language in which the program is written, and then uses a language-agnostic verification algorithm to prove the program correct with respect to its specification, using directly the formal language semantics. Such a complex verifier can easily have bugs. This paper proposes a method to certify the correctness of each successful verification run by generating a proof certificate for it. The proof certificate can be checked by a small proof checker. The preliminary experiments apply the method to generate proof certificates for the verification of an imperative language, a functional language, and a virtual machine language, showing that the proposed method is language-agnostic.},
  techrep           = {https://hdl.handle.net/2142/112785},
  selected          = {true},
}

@Article{CLR22,
  author            = {Chen, Xiaohong and Lucanu, Dorel and Ro{\c{s}}u, Grigore},
  title             = {Capturing constrained constructor patterns in matching logic},
  journal           = {Journal of Logical and Algebraic Methods in Programming},
  year              = {2022},
  volume            = {130},
  abstract          = {Reachability logic for rewrite theories consists of a specification 
                       of system states that are given by constrained constructor patterns, 
                       a transition relation that is given by a rewrite theory, and reachability 
                       properties expressed as pairs of state specifications. Matching logic 
                       has been recently proposed as a unifying foundation for programming languages, 
                       specification and verification. It is known that reachability properties 
                       can be naturally expressed in matching logic. In this paper, we show 
                       that constrained constructor patterns can be faithfully specified as 
                       a matching logic theory. As a result, we obtain a full encoding of reachability 
                       logic for rewrite theories as matching logic theories, by combining the two encodings. 
                       We also show that the main properties of constrained constructor patterns 
                       can be specified and proved within matching logic, using the existing proof system.},
  pdf               = {CLR22-paper.pdf},
  slides            = {CLR22-slides.pdf},
  doi               = {10.1016/j.jlamp.2022.100810},
}

@InProceedings{ZCS22,
  author            = {Zhang, Xiyue and Chen, Xiaohong and Sun, Meng},
  title             = {Towards a unifying logical framework for neural networks},
  booktitle         = {Proceedings of ICTAC},
  year              = {2022},
  abstract          = {Neural networks are increasingly used in safety-critical applications such as medical diagnosis and autonomous driving, which calls for the need for formal specification of their behaviors. In this paper, we use matching logic—a unifying logic to specify and reason about programs and computing systems—to axiomatically define dynamic propagation and temporal operations in neural networks and to formally specify common properties about neural networks. As instances, we use matching logic to formalize a variety of neural networks, including generic feed-forward neural networks with different activation functions and recurrent neural networks. We define their formal semantics and several common properties in matching logic. This way, we obtain a unifying logical framework for specifying neural networks and their properties.},
  doi               = {10.1007/978-3-031-17715-6_28},
  pdf               = {ZCS22-paper.pdf},
}

@InProceedings{BCH+22,
  author            = {Bereczky, Péter and Chen, Xiaohong and Horpácsi, Dániel and Peña, Lucas and Tušil, Jan},
  title             = {Mechanizing matching logic in {C}oq},
  booktitle         = {Proceedings of Working Formal Methods Symposium (FROM)},
  year              = {2022},
  abstract          = {Matching logic is a formalism for specifying and reasoning about mathematical structures, using patterns and pattern matching. Growing in popularity, it has been used to define many logical systems such as separation logic with recursive definitions and linear temporal logic. In addition, it serves as the logical foundation of the K semantic framework, which was used to build practical verifiers for a number of real-world languages. Despite being a fundamental formal system accommodating substantial theories, matching logic lacks a general-purpose, machine-checked formalization. Hence, we formalize matching logic using the Coq proof assistant. Specifically, we create a new representation of matching logic that uses a locally nameless encoding, and we formalize the syntax, semantics, and proof system of this representation in the Coq proof assistant. Crucially, we prove the soundness of the formalized proof system and provide a means to carry out interactive matching logic reasoning in Coq. We believe this work provides a previously unexplored avenue for reasoning about matching logic, its models, and the proof system.},
  doi               = {10.4204/EPTCS.369.2},
  pdf               = {BCH+22-paper.pdf},
}



@Article{SCS+22,
  author            = {Saxena, Manasvi and Chen, Xiaohong and Song, Shuang and Meng, Shaoyu and Sha, Lui and Ro{\c{s}}u, Grigore},
  journal           = {Technical Report},
  title             = {Rewriting-based computer-interpretable clinical practice guidelines},
  year              = {2022},
  abstract          = {Clinical Practice Guidelines (CPGs) are systematically developed statements to assist healthcare professionals with decisions about specific clinical circumstances. Produced by domain experts, they they codify recommended treatments, and are often used as models for building Decision Support Systems (DSS) that assist healthcare professionals adhere to CPGs. CPGs are usually specified informally, or semi-formally (via flowcharts). This, however, may cause the behavior of DSSs to deviate from intended treatment in the corresponding CPGs, and introduce challenges in verifying correctness of the DSSs. In this paper, we propose a novel method of formally specifying CPGs by for- malizing them in K, a rewriting-based executable semantics framework [13]. Our K-based guidelines are executable, allowing them to serve as correct-by-construction models in DSSs, and can be analyzed using tools in the K ecosystem. To support our claims, we present a DSS based on Advanced Cardiac Life Support (ACLS) CPG formalized in K, discuss challenges and present directions for future work.},
  techrep           = {https://hdl.handle.net/2142/116016},
}

@InProceedings{CLTR21,
  author            = {Chen, Xiaohong and Lin, Zhengyao and Trinh, Minh-Thai and Ro{\c{s}}u, Grigore},
  booktitle         = {Proceedings of CAV},
  title             = {Towards a trustworthy semantics-based language framework via proof generation},
  year              = {2021},
  abstract          = {We pursue the vision of an ideal language framework, where programming 
language designers only need to define the formal syntax and semantics
of their languages, and all language tools are automatically  generated
by the framework. Due to the complexity of such a language framework,
it is a big challenge to  ensure its trustworthiness and to  establish
the correctness of the autogenerated language tools.  In this paper, we
propose an innovative approach based on  proof generation. The key idea
is to generate proof objects as correctness certificates for each
individual task that the language tools conduct, on a case-by-case basis,
and use a trustworthy proof checker to check the proof objects. This way,
we avoid formally verifying the entire framework, which is practically
impossible, and thus can make the language framework both practical and
trustworthy. As a first step, we formalize program execution as mathematical
proofs and generate their complete proof objects. The experimental result
shows that the performance of our proof object generation and proof
checking is very promising.},
  pdf               = {CLTR21-paper.pdf},
  slides            = {CLTR21-slides.pdf},
  doi               = {10.1007/978-3-030-81688-9_23},
  selected          = {true},
}

@Article{CR21,
  author            = {Chen, Xiaohong and Ro\c{s}u, Grigore},
  journal           = {Formal Methods in Outer Space},
  title             = {The K vision for the future of programming language design and analysis},
  year              = {2021},
  pages             = {3-9},
  abstract          = {Formal programming language semantics should be a unique opportunity to give birth to a better language, not a cumbersome post-mortem activity. Moreover, language implementations and analysis tools should be automatically generated from the formal semantics in a correct-by-construction manner, at no additional cost. In this paper, we discuss how we are pursuing this vision of programming language design and analysis within the context of the K framework (http://kframework.org), where it is easy and fun to design and deploy new programming languages; where language designers can focus on the desired features and not worry about their implementation; and where the correctness of all auto-generated language implementations and tools is guaranteed on a case-by-case basis, and every individual task, be it parsing, execution, verification, or anything else, is endorsed by its own proof object that can be independently checked by third-party proof checkers, making no compromise to safety or correctness.},
  doi               = {10.1016/j.jlamp.2021.100638},
  pdf               = {CR21-paper.pdf},
}

@Article{CLR21,
  author            = {Chen, Xiaohong and Lucanu, Dorel and Ro\c{s}u, Grigore},
  journal           = {Journal of Logical and Algebraic Methods in Programming},
  title             = {Matching logic explained},
  year              = {2021},
  pages             = {1--36},
  volume            = {120},
  abstract          = {Matching logic was recently proposed as a unifying logic for specifying and reasoning about static structure and dynamic behavior of programs. In matching logic, patterns and specifications are used to uniformly represent mathematical domains (such as numbers and Boolean values), datatypes, and transition systems, whose properties can be reasoned about using one fixed matching logic proof system. In this paper we give a tutorial of matching logic. We use a suite of examples to explain the basic concepts of matching logic and show how to capture many important mathematical domains, datatypes, and transition systems using patterns and specifications. We put emphasis on the general principles of induction and coinduction in matching logic and show how to do inductive and coinductive reasoning about datatypes and codatatypes. To encourage the future tools development for matching logic, we propose and use throughout the paper a human-readable formal syntax to write specifications in a modular and compact way.},
  doi               = {10.1016/j.jlamp.2021.100638},
  pdf               = {CLR21-paper.pdf},
}

@Article{LCT+21,
  author            = {Lin, Zhengyao and Chen, Xiaohong and Trinh, Minh-Thai and Wang, John and Ro{\c{s}}u, Grigore},
  journal           = {Technical Report},
  title             = {Making formal verification trustworthy via proof generation},
  year              = {2021},
  abstract          = {Formal deductive verification aims at proving the correctness of programs via logical deduction. However, the fact that it is usually based on complex program logics makes it error-prone to implement. This paper addresses the important research question of how we can make a deductive verifier trustworthy through a practical approach. We propose a novel technique to generate machine-checkable proof objects to certify each verification task performed by the language-agnostic deductive verifier of K---a semantics-based language framework. These proof objects encode formal proofs in matching logic---the logical foundation of K. They have a small 240-line trust base and can be directly verified by third-party proof checkers. Our preliminary experiments show promising performance in generating correctness proofs for deductive verification in different programming languages.},
  techrep           = {https://hdl.handle.net/2142/112785},
}

@Article{LCR21,
  author            = {Lin, Zhengyao and Chen, Xiaohong and Ro{\c{s}}u, Grigore},
  journal           = {Technical Report},
  title             = {An interactive theorem prover for matching logic with proof object generation},
  year              = {2021},
  abstract          = {Matching logic is a uniform logical foundation for K, which is a language semantics framework with the philosophy that all tooling around a language should be automatically generated from a single, rigorous definition of its formal semantics. In practice, K has been widely used to define the formal semantics of many real-world languages and to generate their execution and verification tools. However, there lacks a generic theorem prover that connects K with its logical foundation---matching logic. In this paper, we present ITP_ML, which is the first interactive theorem prover for matching logic. The main advantage of ITP_ML is its ability to generate machine-checkable proof objects as certificates that witness the correctness of its formal reasoning. ITP_ML is built on top of Metamath, a language to define formal systems, which allows it to have a small trust base of only 250 lines of code. ITP_ML supports both backward and forward proofs, allows users to dynamically add intermediate lemmas, and features automated proof tactics for common utilities such as reasoning about notations and proving propositional tautologies.},
  techrep           = {https://hdl.handle.net/2142/111650},
}

@InProceedings{CR20,
  author      = {Chen, Xiaohong and Ro\c{s}u, Grigore},
  booktitle   = {Proceedings of ICFP},
  title       = {A general approach to define binders using matching logic},
  year        = {2020},
  abstract    = {We propose a novel definition of binders using matching logic, where the binding behavior of object-level binders is directly inherited from the built-in exists binder of matching logic. We show that the behavior of binders in various logical systems such as lambda-calculus, System F, pi-calculus, pure type systems, can be axiomatically defined in matching logic as notations and logical theories. We show the correctness of our definitions by proving conservative extension theorems, which state that a sequent/judgment is provable in the original system if and only if it is provable in matching logic, in the corresponding theory. Our matching logic definition of binders also yields models to all binders, which are deductively complete with respect to formal reasoning in the original systems. For lambda-calculus, we further show that the yielded models are representationally complete, a desired property that is not enjoyed by many existing lambda-calculus semantics. This work is part of a larger effort to develop a logical foundation for the programming language semantics framework K (http://kframework.org).},
  doi         = {10.1145/3408970},
  pdf         = {CR20-paper.pdf},
  slides      = {CR20-slides.pdf},
  talk        = {https://www.youtube.com/watch?v=TNO_jGr33VM},
  techrep     = {https://hdl.handle.net/2142/106608},
  selected    = {true},
}

@InProceedings{CTR+20,
  author            = {Chen, Xiaohong and Trinh, Minh-Thai and Rodrigues, Nishant and Pe{\~{n}}a, Lucas and Ro\c{s}u, Grigore},
  booktitle         = {Proceedings of OOPSLA},
  title             = {Towards A unified proof framework for automated fixpoint reasoning using matching logic},
  year              = {2020},
  abstract          = {Automation of fixpoint reasoning has been extensively studied for various mathematical structures, logical formalisms, and computational domains, resulting in specialized fixpoint provers for heaps, for streams, for term algebras, for temporal properties, for program correctness, and for many other formal systems and inductive and coinductive properties. However, in spite of great theoretical and practical interest, there is no unified framework for automated fixpoint reasoning. Although several attempts have been made, there is no evidence that such a unified framework is possible, or practical. In this paper, we propose a candidate based on matching logic, a formalism recently shown to theoretically unify the above mentioned formal systems. Unfortunately, the (Knaster-Tarski) proof rule of matching logic, which enables inductive reasoning, is not syntax-driven. Worse, it can be applied at any step during a proof, making automation seem hopeless. Inspired by recent advances in automation of inductive proofs in separation logic, we propose an alternative proof system for matching logic, which is amenable for automation. We then discuss our implementation of it, which although not superior to specialized state-of-the-art automated provers for specific domains, we believe brings some evidence and hope that a unified framework for automated reasoning is not out of reach.},
  doi               = {10.1145/3428229},
  pdf               = {CTR+20-paper.pdf},
  slides            = {CTR+20-slides.pdf},
  talk              = {https://www.youtube.com/watch?v=2JlaJPPilB0},
  selected          = {true},
}

@InProceedings{CR20a,
  author            = {Chen, Xiaohong and Ro{\c{s}}u, Grigore},
  title             = {K---A semantic framework for programming languages and formal analysis},
  booktitle         = {Lecture Notes of the International School on Engineering Trustworthy Software Systems},
  year              = {2020},
  abstract          = {We give an overview on the applications and foundations of the K language framework, a semantic framework for programming languages and formal analysis tools. K represents a 20-year effort in pursuing the ideal language framework vision, where programming languages must have formal definitions, and tools for a given language, such as parsers, interpreters, compilers, semantic-based debuggers, state-space explorers, model checkers, deductive program verifiers, etc., can be derived from just one reference formal definition of the language, which is executable, and no other semantics for the same language should be needed. The correctness of the language tools is guaranteed on a case-by-case basis by proof objects, which encode rigorous mathematical proofs as certificates for every individual task that the tools do and can be mechanically checked by third-party proof checkers.},
  doi               = {10.1007/978-3-030-55089-9_4},
  pdf               = {CR20a-paper.pdf},
}

@Article{CLR20,
  author      = {Chen, Xiaohong and Lucanu, Dorel and Ro\c{s}u, Grigore},
  journal     = {Technical Report},
  title       = {Initial algebra semantics in matching logic},
  year        = {2020},
  techrep     = {http://hdl.handle.net/2142/107781},
}

@InProceedings{CR19, 
  author    = {Chen, Xiaohong and Ro{\c{s}}u, Grigore},
  booktitle = {Proceedings of LICS},
  title     = {Matching $\mu$-logic},
  pages     = {1--13},
  year      = {2019},
  publisher = {IEEE},
  abstract  = {Matching logic is a logic for specifying and reasoning about
               structure by means of patterns and pattern matching.
               This paper makes two contributions.
               First, it proposes a sound and complete proof system for
               matching logic in its full generality.
               Previously, sound and complete deduction for matching logic
               was known only for particular theories providing equality
               and membership.
               Second, it proposes matching $\mu$-logic, an extension of
               matching logic with a least fixpoint $\mu$-binder.
               It is shown that matching $\mu$-logic captures as special instances many
               important logics in mathematics and computer science, including
               first-order logic with least fixpoints, modal mu-logic
               as well as dynamic logic and various temporal logics such as
               infinite/finite-trace linear temporal logic and computation tree logic,
               and notably reachability logic, the underlying logic of the K framework
               for programming language semantics and formal analysis.
               Matching $\mu$-logic therefore serves as a unifying foundation for
               specifying and reasoning about fixpoints and induction, 
               programming languages and program specification and verification.},
  doi       = {10.1109/LICS.2019.8785675},
  selected  = {true},
  pdf       = {CR19-paper.pdf},
  slides    = {CR19-slides.pdf},
  techrep   = {https://hdl.handle.net/2142/102281},
}

@InProceedings{CR18,
  author    = {Chen, Xiaohong and Ro{\c{s}}u, Grigore},
  booktitle = {Proceedings of ISoLA},
  title     = {A language-independent program verification framework},
  year      = {2018},
  abstract  = {This invited paper describes an approach to language-independent deductive verification using the K semantics framework, in which an operational semantics of a language is defined and a program verifier together with other language tools are generated automatically, correct-by-construction.},
  doi       = {10.1007/978-3-030-03421-4_7},
  pdf       = {CR18-paper.pdf},
}

@InProceedings{CPR18,
  author    = {Chen, Xiaohong and Park, Daejun and Ro{\c{s}}u, Grigore},
  booktitle = {Proceedings of ISoLA},
  title     = {A language-independent approach to smart contract verification},
  year      = {2018},
  abstract  = {This invited paper reports the current progress on smart contract verification with the K framework in a language-independent style.},
  doi       = {10.1007/978-3-030-03427-6_30},
  pdf       = {CPR18-paper.pdf},
}

@InProceedings{WCSQ17,
  author    = {Wang, Jingyi and Chen, Xiaohong and Sun, Jun and Qin, Shengchao},
  booktitle = {Proceedings of ICFEM},
  title     = {Improving probability estimation through active probabilistic model learning},
  year      = {2017},
  abstract  = {It is often necessary to estimate the probability of certain events occurring in a system. For instance, knowing the probability of events triggering a shutdown sequence allows us to estimate the availability of the system. One approach is to run the system multiple times and then construct a probabilistic model to estimate the probability. When the probability of the event to be estimated is low, many system runs are necessary in order to generate an accurate estimation. For complex cyber-physical systems, each system run is costly and time-consuming, and thus it is important to reduce the number of system runs while providing accurate estimation. In this work, we assume that the user can actively tune the initial configuration of the system before the system runs and answer the following research question: how should the user set the initial configuration so that a better estimation can be learned with fewer system runs. The proposed approach has been implemented and evaluated with a set of benchmark models, random generated models, and a real-world water treatment system.},
  doi       = {10.1007/978-3-319-68690-5_23},
  pdf       = {WCSQ17-paper.pdf},
}

@Article{PCL+16,
  author            = {Palomar, Esther and Chen, Xiaohong and Liu, Zhiming and Maharjan, Sabita and Bowen, Jonathan},
  title             = {Component-based modelling for scalable smart city systems interoperability: A case study on integrating energy demand response systems},
  journal           = {Sensors},
  year              = {2016},
  volume            = {16},
  number            = {11},
  abstract          = {Smart city systems embrace major challenges associated with climate change, energy efficiency, mobility and future services by embedding the virtual space into a complex cyber-physical system. Those systems are constantly evolving and scaling up, involving a wide range of integration among users, devices, utilities, public services and also policies. Modelling such complex dynamic systems' architectures has always been essential for the development and application of techniques/tools to support design and deployment of integration of new components, as well as for the analysis, verification, simulation and testing to ensure trustworthiness. This article reports on the definition and implementation of a scalable component-based architecture that supports a cooperative energy demand response (DR) system coordinating energy usage between neighbouring households. The proposed architecture, called refinement of Cyber-Physical Component Systems (rCPCS), which extends the refinement calculus for component and object system (rCOS) modelling method, is implemented using Eclipse Extensible Coordination Tools (ECT), i.e., Reo coordination language. With rCPCS implementation in Reo, we specify the communication, synchronisation and co-operation amongst the heterogeneous components of the system assuring, by design scalability and the interoperability, correctness of component cooperation.},
  pdf               = {PCL+16-paper.pdf},
  doi               = {10.3390/s16111810},
}

@InProceedings{KLC+16,
  author    = {Kong, Pingfan and Li, Yi and Chen, Xiaohong and Sun, Jun and Sun, Meng and Wang, Jingyi},
  booktitle = {Proceedings of FM},
  title     = {Towards concolic testing for hybrid systems},
  year      = {2016},
  abstract  = {Hybrid systems exhibit both continuous and discrete behavior. Analyzing hybrid systems is known to be hard. Inspired by the idea of concolic testing (of programs), we investigate whether we can combine random sampling and symbolic execution in order to effectively verify hybrid systems. We identify a sufficient condition under which such a combination is more effective than random sampling. Furthermore, we analyze different strategies of combining random sampling and symbolic execution and propose an algorithm which allows us to dynamically switch between them so as to reduce the overall cost. Our method has been implemented as a web-based checker named HyChecker. HyChecker has been evaluated with benchmark hybrid systems and a water treatment system in order to test its effectiveness.},
  doi       = {10.1007/978-3-319-48989-6_28},
  pdf       = {KLC+16-paper.pdf},
}

@InProceedings{LC16,
  author    = {Liu, Zhiming and Chen, Xiaohong},
  booktitle = {Lecture Notes of the International School on Engineering Trustworthy Software Systems},
  title     = {Model-driven design of object and component systems},
  year      = {2016},
  abstract  = {The notion of software engineering implies that software design and production should be based on the types of theoretical foundations and practical disciplines that are established in the traditional branches of engineering. The goal is to make development of complex software systems more predictable and the systems developed more trustworthy - safe, secure and dependable. A number of theories have been well developed in the past half a century, including Abstract Data Types, Hoare Logic, Process Calculi, and I/O automata, and those alike. Based on them, techniques and tools have been developed for software specification, refinement and verification.
However, the theoretically sound techniques and tools have not been seamlessly integrated in practical software development, and their impact upon commonly-used software systems is still far from convincing to software engineering practitioners. This is clearly reflected by the challenges of their applications in engineering large-scale systems, including Cyber-Physical Systems (CPS), Networks of Things and Cloud-Based Systems, that have multi-dimensional complexities. Indeed, students are not often shown how the theories, and their underpinned techniques and tools, can better inform the software engineering they are traditionally taught. The purpose of this course to demonstrate such an effort.
We present a model-driven design framework for component-based and object-oriented software systems. We identify a set of UML notations and textual descriptions for representing different abstractions of software artefacts produced in different development stages. These abstractions, their relations and manipulations all have formalisations in the rCOS formal method of component and object systems. The aim is to allow the advantage of using precise models for development better appreciated. We organise the lecture notes into three chapters, each having a title page but all the references to literature are given at the end of Part III.},
  doi       = {10.1007/978-3-319-29628-9_4},
  pdf       = {LC16-paper.pdf},
}

@InProceedings{LCWS15,
  author    = {Li, Shaodong and Chen, Xiaohong and Wang, Yiwu and Sun, Meng},
  booktitle = {Proceedings of TASE},
  title     = {A framework for off-line conformance testing of timed connectors},
  year      = {2015},
  abstract  = {Coordination is playing a key role in complex cyber-physicalsystems (CPSs). The complexity and importance of coordination models and languages for CPSs necessarily lead to a higher relevance of testing during development of CPSs. Model-based testing is a promising technology to test the conformance or non-conformance relation between the implementation-under-test (IUT) and its specification. In this paper, we present an approach to test the conformance relation tiococ(Timed Input-Output Conformance) between the implementation of a timed Reo connector and its specification given by a timed constraint automaton (TCA). An algorithm to generate test cases from a TCA is proposed and the testing approach is implemented in UPPAAL.},
  doi       = {10.1109/TASE.2015.9},
  pdf       = {LCWS15-paper.pdf},
}

@InProceedings{CSS14,
  author    = {Chen, Xiaohong and Sun, Jun and Sun, Meng},
  booktitle = {Proceedings of ICFEM},
  title     = {A hybrid model of connectors in cyber-physical systems},
  year      = {2014},
  abstract  = {Coordination is playing a key role in complex cyber-physicalsystems (CPSs). The complexity and importance of coordination models and languages for CPSs necessarily lead to a higher relevance of testing during development of CPSs. Model-based testing is a promising technology to test the conformance or non-conformance relation between the implementation-under-test (IUT) and its specification. In this paper, we present an approach to test the conformance relation tiococ(Timed Input-Output Conformance) between the implementation of a timed Reo connector and its specification given by a timed constraint automaton (TCA). An algorithm to generate test cases from a TCA is proposed and the testing approach is implemented in UPPAAL.},
  doi       = {10.1007/978-3-319-11737-9_5},
  pdf       = {CSS14-paper.pdf},
}